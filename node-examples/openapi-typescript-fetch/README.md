
### Using OpenAPI-TypeScript and OpenAPI-Fetch

The [OpenAPI TypeScript](https://openapi-ts.dev/) project is a pair of packages useful functionality.  The `openapi-typescript` package auto-generates TypeScript type definitions, and the `openapi-fetch` package auto-generates a client library.

The types are generated this way:

```shell
$ npx openapi-typescript ./path/to/my/schema.yaml -o ./path/to/my/schema.d.ts
```

The generated TypeScript types are useful except that they do not include some of the JSDOC tags.  [I've filed an issue showing how to add support for `@pattern`, `@format`, and `@nullable`](https://github.com/openapi-ts/openapi-typescript/issues/1955).

The `openapi-fetch` package does not auto-generate source code for the functions.  Instead, they're dynamically generated from the OpenAPI definition.

```js
// generated by openapi-typescript
import type { paths } from "./my-openapi-3-schema";

const client = createClient<paths>({
    baseUrl: "https://myapi.dev/v1/"
});
```

The file `./my-openapi-3-schema` is the type declarations generated by `openapi-typescript`.  The `paths` object lists, per API endpoint path, information about invoking that endpoint.

Hence, the `client` object is dynamically created from the auto-generated `paths` object.

To generate authentication tokens, `openapi-fetch` supports a _middleware_ concept.  Middleware functions are executed on each client request.  For this purpose I created a private `OADR3Client` method:

```js
#authMiddleware: Middleware = ((self) => {
    return <Middleware>{
    async onRequest({ request }) {
        // ...
    }
}})(this);
```

The `onRequest` method is therefore invoked by `openapi-fetch` on each request, and has access to the `OADR3Client` object as the `self` parameter as shown here.

The handler function then uses `fetchToken` which we saw earlier to retrieve the `auth_token`, and then add an `Authorization` header to the outgoing request.

With authentication taken care of, a method for invoking a REST operation is:

```js
async searchAllEvents(
    params: OADR3bis.SearchAllEventsQueryParams
) : Promise<Array<OADR3.Event> | undefined> {

    const searchEvents = validateParams<
        OADR3.SearchAllEventsQueryParams | undefined
    >(
        OADR3.joiValidateSearchAllEvents, params
    );
    
    const { data, error }
    = await this.#client.GET('/events',
        { query: params }
    );
    if (error) {
        throw new Error(`searchAllEvents ERROR ${error.type} ${error.status} ${error.title} ${error.detail}`);
    }

    return validateBodyArray<OADR3.Event>(
        OADR3.joiValidateEvent, data
    );
}
```

The `client` object returned by `openapi-fetch` is stored in `OADR3Client` as `this.#client`.  Invoking a REST method via this client means using `GET`, `POST`, etc methods, along with the endpoint pathname, and any options required by the particular request.

The same validation code is required as with the hand-generated method shown earlier.  The `openapi-fetch` client relieves us of writing the code to generate, invoke, and process the request.
